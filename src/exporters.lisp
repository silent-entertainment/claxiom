(in-package #:claxiom)

(defmethod export-cell (format cell-language cell-type cell)
  (format t "~s~%" (list :default-cell format cell-language cell-type))
  (list :exported format cell-language cell-type (mapcar #'car cell)))

(defun export-cells (format book)
  (map-cells
   (lambda (cell)
     (export-cell
      format
      (aget :cell-language cell)
      (aget :cell-type cell)
      cell))
   book))

(defmethod mimetype-of (format) "text/plain")
(defmethod export-as (format (book notebook))
  (format nil "~{~a~%~%~}" (export-cells format book)))

;;;;;;;;;; Default :lisp exporter
(defmethod filename-of ((format (eql :lisp)) book)
  (format nil "~a.lisp" (notebook-name book)))
(defmethod mimetype-of ((format (eql :lisp))) "text/x-common-lisp")
(defmethod export-as ((format (eql :lisp)) (book notebook))
  (format nil ";; Generated by :claxiom from ~a ~%~%~{~a~^~%~%~}~%"
          (notebook-id book)
          (export-cells :lisp book)))

(defmethod export-cell ((format (eql :lisp)) (cell-language (eql :common-lisp)) cell-type cell)
  nil)
(defmethod export-cell ((format (eql :lisp)) (cell-language (eql :common-lisp)) (cell-type (eql :code)) cell)
  (format nil ";;; Cell ~a~%~a" (aget :id cell) (aget :contents cell)))

;;;;;;;;;; Default :html exporter
(defmethod filename-of ((format (eql :html)) book)
  (format nil "~a.html" (notebook-name book)))
(defun slurp (filename)
  (with-open-file (s filename)
    (apply #'concatenate 'string
           (loop for ln = (read-line s nil nil)
              while ln collect ln))))

(defmethod mimetype-of ((format (eql :html))) "text/html")
(defmethod export-as ((format (eql :html)) (book notebook))
  (with-html-output-to-string (s nil :prologue t :indent t)
    (:html
     (:head
      (:title (str (notebook-name book)))
      (:script :type "text/javascript" (str *base-js*))

      (:style :type "text/css" :media "screen"
              (fmt
               "<!-- ~a -->"
               (slurp (merge-pathnames "static/css/codemirror.css" *static*))))
      (:style :type "text/css" :media "screen"
              (fmt "<!-- ~a -->"
                   (cl-css:css (loop for v being the hash-values of *addon-css-rules* append v))))
      (:style :type "text/css" :media "screen"
              (fmt "<!-- ~a -->" *notebook-css*)))
     (:body
      (:h1 (str (notebook-name book)))
      (:ul :class "cells"
           (str (format nil "~{~a~}" (export-cells format book))))))))

(defun -cell-class (cell)
  (format nil "cell ~(~a~)" (aget :cell-type cell)))
(defun -cell-comment (cell)
  (format nil "<!-- Cell ~a -->~%" (aget :id cell)))
(defun -html-value (cell)
  (aget :value (first (aget :values (first (aget :result cell))))))

(defmethod export-cell ((format (eql :html)) cell-language (cell-type (eql :markup)) cell)
  (html-to-str
   (-cell-comment cell)
   (:li :class (-cell-class cell) :cell-id (aget :id cell) (str (-html-value cell)))))
(defmethod export-cell ((format (eql :html)) cell-language (cell-type (eql :code)) cell)
  (html-to-str
   (-cell-comment cell)
   (:li :class (-cell-class cell) :cell-id (aget :id cell)
        (:pre :class "cell-contents" (str (aget :contents cell)))
        (case (aget :cell-noise cell)
          (:silent nil)
          (t (htm (:pre :class "results" (str (-html-value cell)))))))))
(defmethod export-cell ((format (eql :html)) (cell-language (eql :common-lisp)) (cell-type (eql :parenscript))  cell)
  (html-to-str
   (-cell-comment cell)
   (:script :type "text/javascript" (str (-html-value cell)))
   (case (aget :cell-noise cell)
     (:silent nil)
     (:verbose
      (htm (:li :class (-cell-class cell) :cell-id (aget :id cell)
                (:pre :class "cell-contents" (str (aget :contents cell)))
                (:pre :class "result" (str (-html-value cell))))))
     (t (htm (:li :class (-cell-class cell) :cell-id (aget :id cell)
                  (:pre :class "cell-contents" (str (aget :contents cell)))))))))

(defun export-book-formats ()
  (loop for m in (closer-mop:generic-function-methods #'export-as)
     for (fmt _) = (closer-mop:method-specializers m)
     when (typep fmt 'closer-mop:eql-specializer)
     collect  (closer-mop:eql-specializer-object fmt)))
